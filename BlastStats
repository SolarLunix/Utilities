import json

def write_json(data: dict, fout:str) -> None:
    with open(fout, "w") as o:
        o.write(json.dumps(data, indent=3))


def fix_jsons(fin:str) -> list:
    json_list = []
    lines = ""
    count = 0

    with open(fin, "r") as r:
        previous = " "
        for item in r:
            if item[0] == "{" and previous[0] == "}":
                fout = fin.replace('.json', f'_{count}.json')
                write_json(json.loads(lines), fout)
                json_list.append(fout)
                lines = ""
                count += 1 
            lines += item
            previous = item
        
        fout = fin.replace('.json', f'_{count}.json')
        write_json(json.loads(lines), fout)
        json_list.append(fout)
    return json_list


def blast_json_to_list(fin:str) -> list:
    data = {}
    with open(fin, "r") as r:
        data = json.load(r)
    
    out_data = [[]]
    for key in data.keys():
        id = key
        fp = data[key]["File Path"]
        bid = "None"
        score = "None"
        expect = "None"
        if "Read_1" in data[key].keys():
            bid = data[key]["Read_1"]["Sequence ID"].strip()
            for line in data[key]["Read_1"]["Sequence Information"]:
                if "Score" in line:
                    split_line = line.split(",")
                    score = split_line[0].split("=")[1].strip()
                    expect = split_line[1].split("=")[1].strip()
                    continue
        out_data.append([id, fp, bid, score, expect])
    return out_data

if __name__ == "__main__":
    barcode = "barcode04"
    json_file = f"D:\\Downloads\\Blast\\{barcode}.json"
    bc = [["ID", "Filepath", "Blast ID", "Score", "Expect"]]
    for item in fix_jsons(json_file):
        bc.extend(blast_json_to_list(item))

    bc = [x for x in bc if x]

    import SLUtils.ConvertTable as CT
    CT.write_list(bc, f"D:\\Downloads\\Blast\\{barcode}.tsv", '\t')

    counts = {}
    filtered = 0
    count = 0
    unique_species = 0
    for item in bc:
        if (item[2] != "None" and item[2] != "Blast ID") and float(item[4] if item[4] is not 'None' else 1)<=0.001:
            count += 1
            hold = item[2].split(' ')
            if "PREDICTED" in hold[1] or "MAG:" in hold[1]:
                genus = hold[2]
            elif "MAG" in hold[1]:
                genus = hold[3]
            else:
                genus = hold[1]

            if genus in counts.keys():
                if item[2] not in counts[genus]["ID List"]:
                    unique_species += 1
                counts[genus]["Count"] += 1
                counts[genus]["ID List"].append(item[2])
                counts[genus]["Score List"].append(item[3])
                counts[genus]["Expect List"].append(item[4])
            else:
                unique_species += 1
                counts.setdefault(genus, {
                    "Count": 1,
                    "ID List": [item[2]],
                    "Score List": [item[3]],
                    "Expect List": [item[4]],
                })
        else:
            filtered += 1

    write_json(counts, f"D:\\Downloads\\Blast\\{barcode}_genus.json")

    genus_list = [["Genus", "Count"]]
    for key in counts.keys():
        genus_list.append([key, counts[key]["Count"]])

    CT.write_list(genus_list, f"D:\\Downloads\\Blast\\{barcode}_genuses.csv", ",")

    total = count + filtered
    unique = len(counts.keys())
    print(f"{barcode} \n\tSaved: {count}, Filtered: {filtered}, Total: {total}, Unique Genuses: {unique}, Unique Species: {unique_species}")

    '''
    ncbi = NCBITaxa()

    def get_desired_ranks(taxid, desired_ranks):
        lineage = ncbi.get_lineage(taxid)
        lineage2ranks = ncbi.get_rank(lineage)
        ranks2lineage = dict((rank, taxid) for (taxid, rank) in lineage2ranks.items())
        return {'{}_id'.format(rank): ranks2lineage.get(rank, '<not present>') for rank in desired_ranks}
    '''